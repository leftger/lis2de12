use std::{
    env, fs,
    io::{self, Write},
    path::{Path, PathBuf},
    str::FromStr,
};

use anyhow::{Context, Result, anyhow, bail};
use clap::Parser;
use device_driver_generation::transform_yaml;
use prettyplease::unparse;
use proc_macro2::TokenStream;
use syn::File;

#[derive(Debug, Parser)]
#[command(
    name = "generate-api",
    about = "Generate the LIS2DE12 Rust API from the YAML device manifest.",
    long_about = "Reads a device manifest and produces the Rust driver scaffolding by leveraging the device-driver-generation crate."
)]
struct Cli {
    #[arg(
        short,
        long,
        value_name = "PATH",
        default_value = "src/lis2de12.yaml",
        help = "Path to the device manifest (YAML)."
    )]
    manifest: PathBuf,

    #[arg(
        short,
        long = "device-name",
        value_name = "IDENT",
        default_value = "Lis2de12Device",
        help = "Name of the generated device type."
    )]
    device_name: String,

    #[arg(
        short,
        long,
        value_name = "PATH",
        help = "Write output to this file instead of stdout."
    )]
    output: Option<PathBuf>,
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    let manifest_path = absolutize_path(&cli.manifest)?;
    let manifest_src = fs::read_to_string(&manifest_path)
        .with_context(|| format!("Failed to read manifest at {}", manifest_path.display()))?;

    let generated = generate_rust(&manifest_src, &cli.device_name, &manifest_path)?;

    let formatted = prettify(&generated).context("Failed to format generated Rust source")?;

    let final_output = add_header(&formatted, &manifest_path);

    if let Some(out_path) = cli.output {
        let out_path = absolutize_path(&out_path)?;
        if let Some(parent) = out_path.parent() {
            fs::create_dir_all(parent).with_context(|| {
                format!("Failed to create output directory {}", parent.display())
            })?;
        }
        fs::write(&out_path, final_output)
            .with_context(|| format!("Failed to write generated code to {}", out_path.display()))?;
    } else {
        let mut stdout = io::stdout().lock();
        stdout
            .write_all(final_output.as_bytes())
            .context("Failed to write generated code to stdout")?;
    }

    Ok(())
}

fn generate_rust(manifest_src: &str, device_name: &str, manifest_path: &Path) -> Result<String> {
    let extension = manifest_path
        .extension()
        .and_then(|ext| ext.to_str())
        .map(|ext| ext.to_ascii_lowercase())
        .unwrap_or_default();

    match extension.as_str() {
        "yaml" | "yml" => Ok(transform_yaml(manifest_src, device_name)),
        other => bail!("Unsupported manifest extension: {other} (expected yaml)"),
    }
}

fn prettify(source: &str) -> Result<String> {
    let tokens = TokenStream::from_str(source)
        .map_err(|err| anyhow!("Unable to parse generated tokens into a TokenStream: {err}"))?;
    let syntax_tree: File =
        syn::parse2(tokens).context("Unable to convert tokens into a syntax tree")?;
    Ok(unparse(&syntax_tree))
}

fn add_header(formatted: &str, manifest_path: &Path) -> String {
    let mut output = String::new();
    output.push_str("// @generated by tools/generate_api\n");
    output.push_str("// Do not edit this file manually.\n");
    output.push_str(&format!(
        "// Source manifest: {}\n\n",
        manifest_path.display()
    ));
    output.push_str(formatted.trim_start_matches('\u{feff}'));
    if !output.ends_with('\n') {
        output.push('\n');
    }
    output
}

fn absolutize_path(path: &Path) -> Result<PathBuf> {
    if path.is_absolute() {
        Ok(path.to_path_buf())
    } else {
        let cwd = env::current_dir().context("Failed to resolve current working directory")?;
        Ok(cwd.join(path))
    }
}
